#!/usr/bin/env python3
"""
CSV Analyzer - Statistical Analysis Tool for CSV Files
Generated by qwen2.5-coder:7b model test

This script reads CSV files and performs comprehensive statistical analysis
on numeric columns, generating detailed summary reports.

Usage:
    python csv_analyzer.py input.csv [--output report.txt] [--column COLUMN]
"""

import argparse
import csv
import sys
import statistics
from pathlib import Path
from typing import List, Dict, Any, Optional
import json


class CSVAnalyzer:
    """Main class for CSV statistical analysis."""
    
    def __init__(self, filepath: str):
        """Initialize analyzer with CSV file path."""
        self.filepath = Path(filepath)
        self.data: List[Dict[str, Any]] = []
        self.numeric_columns: List[str] = []
        
    def load_data(self) -> None:
        """Load and validate CSV data."""
        try:
            with open(self.filepath, 'r', newline='', encoding='utf-8') as csvfile:
                # Detect delimiter
                sample = csvfile.read(1024)
                csvfile.seek(0)
                sniffer = csv.Sniffer()
                delimiter = sniffer.sniff(sample).delimiter
                
                # Read CSV data
                reader = csv.DictReader(csvfile, delimiter=delimiter)
                self.data = list(reader)
                
                if not self.data:
                    raise ValueError("CSV file is empty")
                    
                # Identify numeric columns
                self._identify_numeric_columns()
                
        except FileNotFoundError:
            raise FileNotFoundError(f"CSV file not found: {self.filepath}")
        except csv.Error as e:
            raise ValueError(f"Error reading CSV file: {e}")
        except Exception as e:
            raise Exception(f"Unexpected error loading data: {e}")
    
    def _identify_numeric_columns(self) -> None:
        """Identify columns containing numeric data."""
        if not self.data:
            return
            
        sample_row = self.data[0]
        for column in sample_row.keys():
            # Check if column contains numeric values
            numeric_count = 0
            total_count = 0
            
            for row in self.data[:100]:  # Sample first 100 rows
                value = row.get(column, '').strip()
                if value:
                    total_count += 1
                    try:
                        float(value)
                        numeric_count += 1
                    except ValueError:
                        continue
            
            # Consider column numeric if >80% of values are numeric
            if total_count > 0 and (numeric_count / total_count) > 0.8:
                self.numeric_columns.append(column)
    
    def _get_numeric_values(self, column: str) -> List[float]:
        """Extract numeric values from a column."""
        values = []
        for row in self.data:
            value = row.get(column, '').strip()
            if value:
                try:
                    values.append(float(value))
                except ValueError:
                    continue
        return values
    
    def analyze_column(self, column: str) -> Dict[str, Any]:
        """Perform statistical analysis on a single column."""
        if column not in self.numeric_columns:
            return {"error": f"Column '{column}' is not numeric"}
        
        values = self._get_numeric_values(column)
        
        if not values:
            return {"error": f"No valid numeric values found in column '{column}'"}
        
        try:
            analysis = {
                "column": column,
                "count": len(values),
                "mean": statistics.mean(values),
                "median": statistics.median(values),
                "std_dev": statistics.stdev(values) if len(values) > 1 else 0,
                "min": min(values),
                "max": max(values),
                "range": max(values) - min(values),
            }
            
            # Calculate mode (handle potential StatisticsError)
            try:
                analysis["mode"] = statistics.mode(values)
            except statistics.StatisticsError:
                analysis["mode"] = "No unique mode"
            
            # Calculate quartiles
            sorted_values = sorted(values)
            n = len(sorted_values)
            analysis["q1"] = statistics.median(sorted_values[:n//2])
            analysis["q3"] = statistics.median(sorted_values[(n+1)//2:])
            analysis["iqr"] = analysis["q3"] - analysis["q1"]
            
            return analysis
            
        except Exception as e:
            return {"error": f"Error analyzing column '{column}': {e}"}
    
    def analyze_all_columns(self) -> Dict[str, Any]:
        """Perform analysis on all numeric columns."""
        results = {
            "file_info": {
                "filename": self.filepath.name,
                "total_rows": len(self.data),
                "total_columns": len(self.data[0].keys()) if self.data else 0,
                "numeric_columns": len(self.numeric_columns)
            },
            "column_analyses": {}
        }
        
        for column in self.numeric_columns:
            results["column_analyses"][column] = self.analyze_column(column)
        
        return results
    
    def generate_report(self, output_file: Optional[str] = None) -> str:
        """Generate a formatted analysis report."""
        analysis = self.analyze_all_columns()
        
        report_lines = [
            "=" * 60,
            "CSV STATISTICAL ANALYSIS REPORT",
            "=" * 60,
            "",
            f"File: {analysis['file_info']['filename']}",
            f"Total Rows: {analysis['file_info']['total_rows']:,}",
            f"Total Columns: {analysis['file_info']['total_columns']}",
            f"Numeric Columns: {analysis['file_info']['numeric_columns']}",
            "",
            "COLUMN ANALYSIS",
            "-" * 30,
        ]
        
        for column, stats in analysis["column_analyses"].items():
            if "error" in stats:
                report_lines.extend([
                    f"\n{column.upper()}:",
                    f"  Error: {stats['error']}"
                ])
                continue
            
            report_lines.extend([
                f"\n{column.upper()}:",
                f"  Count: {stats['count']:,}",
                f"  Mean: {stats['mean']:.2f}",
                f"  Median: {stats['median']:.2f}",
                f"  Mode: {stats['mode']}",
                f"  Std Dev: {stats['std_dev']:.2f}",
                f"  Min: {stats['min']:.2f}",
                f"  Max: {stats['max']:.2f}",
                f"  Range: {stats['range']:.2f}",
                f"  Q1: {stats['q1']:.2f}",
                f"  Q3: {stats['q3']:.2f}",
                f"  IQR: {stats['iqr']:.2f}",
            ])
        
        report_lines.extend([
            "",
            "=" * 60,
            "End of Report"
        ])
        
        report = "\n".join(report_lines)
        
        if output_file:
            try:
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(report)
                print(f"Report saved to: {output_file}")
            except Exception as e:
                print(f"Error saving report: {e}")
        
        return report


def main():
    """Main function with command-line interface."""
    parser = argparse.ArgumentParser(
        description="Analyze CSV files and generate statistical reports",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python csv_analyzer.py data.csv
  python csv_analyzer.py data.csv --output report.txt
  python csv_analyzer.py data.csv --column sales --output sales_report.txt
        """
    )
    
    parser.add_argument(
        'input_file',
        help='Path to the CSV file to analyze'
    )
    
    parser.add_argument(
        '--output', '-o',
        help='Output file for the report (optional, prints to stdout if not specified)'
    )
    
    parser.add_argument(
        '--column', '-c',
        help='Analyze only a specific column (optional, analyzes all numeric columns if not specified)'
    )
    
    parser.add_argument(
        '--json',
        action='store_true',
        help='Output results in JSON format'
    )
    
    args = parser.parse_args()
    
    try:
        # Initialize analyzer
        analyzer = CSVAnalyzer(args.input_file)
        
        # Load data
        print(f"Loading data from {args.input_file}...")
        analyzer.load_data()
        
        if not analyzer.numeric_columns:
            print("Warning: No numeric columns found in the CSV file.")
            return
        
        print(f"Found {len(analyzer.numeric_columns)} numeric columns: {', '.join(analyzer.numeric_columns)}")
        
        # Perform analysis
        if args.column:
            if args.column not in analyzer.numeric_columns:
                print(f"Error: Column '{args.column}' is not found or not numeric.")
                print(f"Available numeric columns: {', '.join(analyzer.numeric_columns)}")
                return
            
            result = analyzer.analyze_column(args.column)
            
            if args.json:
                output = json.dumps(result, indent=2)
            else:
                if "error" in result:
                    output = f"Error: {result['error']}"
                else:
                    output = f"""
Analysis for column '{args.column}':
  Count: {result['count']:,}
  Mean: {result['mean']:.2f}
  Median: {result['median']:.2f}
  Mode: {result['mode']}
  Std Dev: {result['std_dev']:.2f}
  Min: {result['min']:.2f}
  Max: {result['max']:.2f}
  Range: {result['range']:.2f}
  Q1: {result['q1']:.2f}
  Q3: {result['q3']:.2f}
  IQR: {result['iqr']:.2f}
"""
        else:
            if args.json:
                result = analyzer.analyze_all_columns()
                output = json.dumps(result, indent=2)
            else:
                output = analyzer.generate_report(args.output)
        
        # Output results
        if not args.output or args.column:
            print(output)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()